# 常见的动态规划

### 解题模版
1. 根据特征判断是否能用动态规划来解（具有最值、可行性、方案总数等的特征就可以考虑）（满足：重复子问题、无后效行、最优子结构）
2. 确定初始化状态和状态参数（状态参数：变化的变量）
3. 确定状态存储数组（即备忘录）
4. 写出关键的状态转移方程
5. 编写代码进行求解
3中最关键的是要定义好数组中的下标与其值的含义，而这个又会依赖于4点中的状态转移方程，如何把状态存储在备忘录中

### 简单路径规划

问题
一个机器人位于一个 m * n 网格的左上角 ，机器人每次只能向下或者向右移动一步，现在机器人试图达到网格的右下角。问总共有多少条不同的路径?

示例：
```rust
输入：m = 3, n = 2
输出： 3 
解释: 从左上角开始，总共有 3 条路径可以到达右下角：
1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右
```

```typescript
var fn = (m, n) => {
  const list = Array.from({ length: n}, () => Array(m).fill(0))
  for(let i = 1; i < n; i++) {
    list[i][0] = 1
  }
  for(let i = 1; i < m; i++) {
    list[0][i] = 1
  }
  // list[i][j] 表示00 到  i j 的方法数
  for(let i = 1; i < n; i++) {
    for(let j = 1; j < m; j++) {
      list[i][j] = list[i - 1][j] + list[i][j - 1]
    }
  }
  return list[n - 1][m -1]
}
fn(3, 2)
```

### 带障碍的路径规划
问题：一个机器人位于一个 m * n 网格的左上角 。机器人每次只能向下或者向右移动一步，现在机器人试图达到网格的右下角。考虑网格中有障碍物，那么从左上角到右下角将会有多少条不同的路径？
网格中的障碍物和空位置分别用 1 和 0 来表示

```rust
示例：

输入：
[ 
  [0, 0, 0], 
  [0, 1, 0], 
  [0, 0, 0] 
]
输出: 2
解释：3 * 3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右
```
```typescript
var fn = (data) => {
  const m = data.length
  const n = data[0].length
  const list = Array.from({ length: n}, () => Array(m).fill(0))
  for(let i = 1; i < n; i++) {
    if(data[i][0]) break
    list[i][0] = 1
  }
  for(let i = 1; i < m; i++) {
    if(data[0][i]) break
    list[0][i] = 1
  }
  // list[i][j] 表示00 到  i j 的方法数
  for(let i = 1; i < n; i++) {
    for(let j = 1; j < m; j++) {
      if(data[i][j]) continue
      list[i][j] = list[i - 1][j] + list[i][j - 1]
    }
  }
  return list[n - 1][m -1]
}
fn([ [0, 0, 0], [0, 1, 0], [0, 0, 0] ])
```

### 跳跃问题
题目：给出一个非负整数数组 A，你最初定位在数组的第一个位置。数组中的每个元素代表你在那个位置可以跳跃的最大长度。判断你是否能到达数组的最后一个位置
```rust
示例1：

输入：A = [2, 3, 1, 1, 6]
输出： True
解释: 我们可以先跳 1 步，从位置 0 到达位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。
```
```typescript
var fn = (list) => {
  let res = true
  let prev = list[0]
  for(let i = 1; i < list.length; i++) { 
    prev = Math.max(prev - 1, list[i])
    if(prev === 0 && i !== list.length - 1) {
      res = false
      break
    }
    
  }
  console.log('res', res)
  return res
}
fn([2, 3, 1, 1, 6]) // true
fn([4, 2, 1, 0, 0, 6]) // false

```
参考答案给的下面的解题，感觉像是在遍历了
```typescript
const canJump = (nums) => {
  const n = nums.length;
  if (n <= 1) { return true; }

  const dp = Array(n).fill(false)
  // 初始化状态
  dp[0] = true;

  for (let i = 1; i < n; i++) {
    for (let j = 0; j < i; j++) { // j < i
      if (dp[j] && j + nums[j] >= i) {
        dp[i] = true;
        break;
      }
    }
  }
  return dp[n - 1]; // 输出答案
}
```

### 买卖股票问题
问题：给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。请你设计一个算法来计算你所能获取的最大利润，你最多可以完成两笔交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
```rust
示例1：

输入：[3, 3, 5, 0, 0, 3, 1, 4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3 - 0 = 3 。随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4 - 1 = 3 。
```
```rust

示例2：

输入：[1, 2, 3, 4, 5]
输出：4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。需要注意的是，你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```
分析：
1. 是否满足动态规划
2. 初始化状态及参数
> 初始化状态：没有买卖任何股票，初始值为 0 
> 参数：一天结束是的总利润取决于三个因素：前一天赚取的总利润，当天结束时是否持有股票，当天是否买卖股票
> 买卖股票次数，天数，是否持有股票
3. 确定状态存储数组（备忘录）
> 