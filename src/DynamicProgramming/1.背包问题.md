# 背包问题

### 描述
对于一组不同重量、不可分割的物品，我们需要选择一些装入背包，在满足背包最大重量限制的前提下，背包中物品总重量的最大值是多少呢？
如：物品重量 [2,2,4,6,3] 背包承受的最大限制 9

```typescript
var knapsack = (weight: number[], w:number) => {
    const n = weight.length
    // 行 为某个石头的决策（放入或不放入背包），列的值为背包的放入值，当列尾true则表示放入背包的值, 0 到 w 共w+1种状态
    const states = Array.from({ length: n}, () => Array.from({ length: w + 1}, () => false))
    // 特殊处理第一行(第一个石块)，因为后面一行都依赖前一行，第一行没前一行
    // 不放入背包
    states[0][0] = true
    // 放入背包
    if(weight[0] <= w) {
        states[0][weight[0]] = true
    }
    debugger
    // 决策第2到n石头
    for(let i = 1; i < n;i++){
        // 不将石头放入背包中
        for(let j = 0; j <= w; j++) {
            // 将上一行的背包值直接放在下一行
            if(states[i - 1][j]) {
                states[i][j] = true
            }
        }
        // 放入背包中
        // for(let j = 0; j < w; j++) {
        //     // 将上一行的背包值直接放在下一行，且不超过最大重量
        //     if(states[i - 1][j] && weight[i] + j <= w) {
        //         states[i][weight[i] + j] = true
        //     }
        // }
        // 放入背包的优化方案（减少循环次数）
        for(let j = 0; j <= w - weight[i]; j++) {
            if(states[i - 1][j]) {
                states[i][j + weight[i]] = true
            }
        }
        
    }
    // 输出结果，遍历最后一行，逆序，第一个为true的即为结果
    for(let i = w; i > 0; i--) {
        if(states[n - 1][i]) return w
    }
}
```

// 上面动态规划方案太费空间了，如果背包足够大，就不行了
// 由于有上一层向一层转移，其实每层就只用了一次，可以用一层就解决了

```typescript
var knapsack = (weight, w) => {
    const n = weight.length
    // 列的值为背包的放入值，当列尾true则表示放入背包的值, 0 到 w 共w+1种状态
    const states = Array.from({ length: w + 1}, () => false)
    // 特殊处理第一行(第一个石块)，因为后面一行都依赖前一行，第一行没前一行
    // 不放入背包
    states[0] = true
    // 放入背包
    if(weight[0] <= w) {
      states[weight[0]] = true
    }
    // 决策第2到n石头
    for(let i = 1; i < n;i++){
        // 由于每次决策后背包的重量只会不变或增加，只能从大到小开始遍历
        for(let j = w - weight[i]; j >= 0; j--) {
            if(states[j]) {
              states[j + weight[i]] = true
            }
        }
    }
    // 输出结果，逆序，第一个为true的即为结果
    for(let i = w; i > 0; i--) {
        if(states[i]) return w
    }
}
```

// 0-1背包问题
```typescript
var knapsack = (list: number[], values: number[], w: number) => {
    n = list.length
    const res = Array(w + 1).fill(0)
    // i 为 第几个物品
    for(let i = 0; i < n ; i++) { // 遍历每个物品
        for(let j = w; j > 0; j--) { // 最大可承受背包重量下的状况，小规模推导大规模的情况,从后往前遍历,因为它子能受上层最小值的推导，如果是从小到大，则受到了本层值遍历的值影响了
            // debugger
            const theW = list[i] // 第 i 个物品的重量
            if(j >= theW) {
               // console.log('res[i + theW], res[i] + values[i]', j, theW, res[j], res[j - theW] + values[i])
               res[j] = Math.max(res[j], res[j - theW] + values[i])
            }
        }
    }
    return[res, res[w]]
}
knapsack([3, 2, 1], [5,2,3], 5)
```
##### 从小到大的遍历方案
// w 从小到大的便利方案
```typescript
var knapsack = (list, values, w) => {
    n = list.length
    const res = Array(w + 1).fill(0)
    // i 为 第几个物品
    for(let i = 0; i < n ; i++) { // 遍历每个物品
        const oldRes = [...res]
        for(let j = 0; j <= w; j++) { // 最大可承受背包重量下的状况，
            // debugger
            const theW = list[i] // 第 i 个物品的重量
            
            if(j >= theW) {
               // console.log('res[i + theW], res[i] + values[i]', j, theW, res[j], res[j - theW] + values[i])
               res[j] = Math.max(oldRes[j], oldRes[j - theW] + values[i])
            } else {
                res[j] = oldRes[j]
            }
        }
    }
    return[res, res[w]]
}
knapsack([3, 2, 1], [5,2,3], 5)
```


## 变种问题
### 问题描述
有一堆石头，每块石头的重量都是正整数。每次从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x≤y。那么粉碎的可能结果如下：如果 x 与 y 相等，那么两块石头都会被完全粉碎；否则，重量为 x 的石头将会完全粉碎，而重量为 y 的石头的新重量为 y−x。最后，最多只会剩下一块石头。返回此时石头最小的可能重量。如果没有石头剩下，就返回 0

```rust
示例：
输入：[1, 2, 1, 7, 9, 4]
输出：
解释：Round 1: (2, 4) -> 2, 数组变成 [1, 1, 7, 9, 2]
     Round 2: (7, 9) -> 2, 数组变成 [1, 1, 2, 2]
     Round 3: (2, 2) -> 0, 数组变成 [1, 1]
     Round 4: (1, 1) -> 0, 数组为空，返回 0
```
暴力递归解法
```typescript
var fn = (list) => {
    let res = null
    if(list.length < 1) return list[0]
    if(list.length === 2) return Math.abs(list[0] - list[1])
    for(let i = 0; i < list.length - 1; i++) {
        for(let j = i+1; j < list.length; j++) {
            const newList = [...list]
            // j > i 所以把 j 删除放在前面
            newList.splice(j, 1)
            newList.splice(i, 1)
            const val = fn([Math.abs(list[i] - list[j]), ...newList])
            res = res == null ? val : Math.min(res, val)
        }
    }
    return res
}
fn([1, 2, 1, 7, 9, 5])
```
[石头粉碎问题](https://time.geekbang.org/column/article/290092)
转化为求两组数字之差最小，即求的n个数之和尽可能的达到所有值（假设为 t）总和的一半，转化为背包问题即为对一些重量不一石头，在背包最大重量为 t/2 的限制情况下最多能背多少
动态规划
```typescript
var fn = (list) => {
    const max = list.reduce((sum, val) => sum + val, 0)
    // 背包最大限制量, 向上取整
    const w = Math.ceil(max / 2)
    const res = Array(w + 1).fill(0)
    for(let i = 0; i < list.length; i++) {
        for(let j = w; j > 0; j--) {
            // 还能装进去
            if(j >= list[i]) {
                res[j] = Math.max(res[j], res[j - list[i]] + list[i])
            }
        }
    }
    return Math.abs(max - 2 * res[w])    
}
fn([1, 2, 1, 7, 9, 4])
```

$$
f(x)= \begin{cases} d(x), x \in V_{I} \\
g(\{v(f(s(x,c)),c)\}),c \in values(x) \end{cases} 
$$
尝试按照上面的公式来解答

```typescript
var fn = (list) => {
    const max = list.reduce((sum, val) => sum + val, 0)
    // 背包最大限制量, 向上取整
    const w = Math.ceil(max / 2)
    const res = Array(w + 1).fill(0)
    for(let i = 0; i < list.length; i++) {
        for(let j = w; j > 0; j--) {
            // 获取备选值子问题的值
            function s (x, c) {
                return [list[x], res[c - list[x]]]
            }
            // 获取子问题的结果
            function f([val, childRes]) {
                return childRes + val
            }
            // 获取子问题的结果与当前值
            function v(changedVal, c) {
                return [changedVal, res[c]]
            }
            // 求解
            function g(values) {
                return Math.max(...values)
            }
            // 还能装进去
            if(j >= list[i]) {
                res[j] = g(v(f(s(i, j)), j))
            }
        }
    }
    return Math.abs(max - 2 * res[w])    
}
fn([1, 2, 1, 7, 9, 5])
```

##### 完全背包问题
问题：给你一个可放总重量为 W 的背包和 N 个物品，对每个物品，有重量 w 和价值 v 两个属性，那么第 i 个物品的重量为 w[i]，价值为 v[i]。现在让你用这个背包装物品，每种物品都可以选择任意多个，问这个背包最多能装的价值是多少？
```rust
示例：
输入：W = 5, N = 3
     w = [3, 2, 1], v = [5, 2, 3]
输出：15
解释：当 i = 2 时，选取 5 次，总价值为 5 * 3 = 15。
```

```typescript
var fn = () => {
    const W = 5, N = 3
    const w = [3,2,1], v = [5, 2, 3]
    const res = Array(W + 1).fill(0)
    // 遍历每个物品
    for(let i = 0; i < N; i++) {
        // 每次决策下，计算某个背包容量下的最优解
        for(let j = W; j >= 0; j--) {
            // 对每个物品尝试多次，0-1是只会有放弃或不放弃的处理
            // k 为 0 时无价值，甚至可以优化为 w 中的最小值
            for(let k = 1; k <= j / w[i]; k++) {
                if(j >= k * w[i]) {
                    res[j] = Math.max(res[j], res[j - k * w[i]] + k * v[i])
                }
            }
        }
    }
    return res[W]
}
fn()
```
// 优化，减少一层遍历，子元素已经是最优解了
[对比方案](##### 从小到大的遍历方案)
```typescript
var fn = () => {
    const W = 5, N = 3
    const w = [3,2,1], v = [5, 2, 3]
    const res = Array(W + 1).fill(0)
    for(let i = 0; i < N; i++) {
        // 此处的从小到大的处理逻辑与【对比方案】指向的有差异
        // res[j] 处利用了本轮的已经变更过的优化方案，来避免对同一个物品的循环判断，避免了重复子问题（其原理还待继续深入理解），后面的值也需要用到前面的值，从前往后计算，且后续的用到前面的值，就能避免持续的重复计算逻辑了，完美
        // https://time.geekbang.org/column/article/291638
        for(let j = 1; j <= W; j++) {
            if(j >= w[i]) {
                res[j] = Math.max(res[j], res[j - w[i]] + v[i])
            }
        }
    }
    return [res[W], res] 
}
fn()
```