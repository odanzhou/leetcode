# 子序列问题
### 问题特征
1. 题目涉及子序列
2. 问题符合动态规划典型特征，特别是求最值问题
3. 题目的答案是题设数组的子序列，或者来源于子序列

##### 最长回文子序列
用子数组中的方式能解决
好像不行, fn('abca') 在子序列中答案应该是3，子序列答案不需要是连续的
```typescript
var fn = (s) => {
  const n = s.length
  const list = Array.from({ length: n }, () => Array(n).fill(false))
  for(let i = 0; i < n; i++) {
    list[i][i] = true
  }
  let res = 1
  for(let i = 1; i < n; i++) {
    for(let j = 0; j < i; j++) {
      list[j][i] = s[i] === s[j] && (i - j < 3 || list[j + 1][i - 1])
      if(list[j][i]) {
        res = Math.max(res, i - j + 1)
      }
    }
  }
  return res
}
fn('asssasms')
```
正确子序列解法
```typescript
var fn = (s) => {
  const n = s.length
  const list = Array.from({ length: n }, () => Array(n).fill(0))
  for(let i = 0; i < n; i++) {
    list[i][i] = 1
  }
  for(let i = 1; i < n; i++) {
    for(let j = 0; j < i; j++) {
      // 如果相等，则在其最长的子序列长度上加2
      if(s[i] === s[j]) {
        list[j][i] = 2 + list[j + 1][i - 1]
      } else { // 如果不等，则取其两个子序列的最大值
        list[j][i] = Math.max(list[j][i - 1], list[j+1][i])
      }
    }
  }
  return list[0][n - 1]
}
fn('abca')
```